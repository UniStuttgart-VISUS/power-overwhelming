// <copyright file="async_sampling.h" company="Visualisierungsinstitut der Universität Stuttgart">
// Copyright © 2023 Visualisierungsinstitut der Universität Stuttgart. Alle Rechte vorbehalten.
// </copyright>
// <author>Christoph Müller</author>

#pragma once

#include "power_overwhelming/measurement.h"
#include "power_overwhelming/timestamp_resolution.h"
#include "power_overwhelming/tinkerforge_sensor_source.h"


namespace visus {
namespace power_overwhelming {

    /* Forward declarations. */
    class sensor;


    /// <summary>
    /// Configures the behaviour of ansychronous sampling of a sensor.
    /// </summary>
    /// <remarks>
    /// <para><see cref="async_sampling" /> is not thread-safe. It is intended
    /// to be configured once and then being passed to the <see cref="sensor" />
    /// where it remains unchanged until the sensor is reconfigured using a
    /// new instance of the class.</para>
    /// </remarks>
    class POWER_OVERWHELMING_API async_sampling final {

    public:

        /// <summary>
        /// The type of the  callback to be invoked if a
        /// <see cref="measurement" /> was generated by a sensor.
        /// </summary>
        typedef measurement_callback on_measurement_callback;

        /// <summary>
        /// The type to represent sampling intervals measured in microseconds.
        /// </summary>
        typedef std::uint64_t microseconds_type;

        /// <summary>
        /// The type of callback to be invoked if a sensor created one of the
        /// new &quot;pure&quot; <see cref="measurement_data" /> samples.
        /// </summary>
        typedef void (*on_measurement_data_callback)(_In_ const sensor&,
            _In_ const measurement_data&, _In_opt_ void *);

        /// <summary>
        /// Initialises a new instance.
        /// </summary>
        /// <remarks>
        /// The new instance is initially configured to disable asynchronous
        /// sampling. Use the fluent API to add the appropriate callback and a
        /// user-defined context as necessary.
        /// </remarks>
        async_sampling(void);

        /// <summary>
        /// Move <paramref name="rhs" /> invalidating it.
        /// </summary>
        /// <param name="rhs">The object to be moved.</param>
        inline async_sampling(_Inout_ async_sampling&& rhs) noexcept {
            *this = std::move(rhs);
        }

        /// <summary>
        /// Gets the user-defined context, if any, to be passed to the callback.
        /// </summary>
        /// <returns>The user-defined context pointer.</returns>
        inline _Ret_maybenull_ const void *context(void) const noexcept {
            return this->_context;
        }

        /// <summary>
        /// Gets the user-defined context, if any, to be passed to the callback.
        /// </summary>
        /// <returns>The user-defined context pointer.</returns>
        inline _Ret_maybenull_ void *context(void) noexcept {
            return this->_context;
        }

        /// <summary>
        /// If the sensor this sampling configuration is passed to is a
        /// Tinkerforge sensor, instructs the sensor to obtain data only from
        /// the specified sources.
        /// </summary>
        /// <remarks>
        /// If the sensor is not a Tinkerforge sensor, this setting has no
        /// effect.
        /// </remarks>
        /// <param name="source">A bitmask of the sources that should be
        /// returned.</param>
        /// <returns><c>*this</c>.</returns>
        async_sampling& from_source(
            _In_ const tinkerforge_sensor_source source) noexcept;

        /// <summary>
        /// Answer the requested sampling interval in microseconds.
        /// </summary>
        /// <returns>The sampling interval in microseconds.</returns>
        inline microseconds_type interval(void) const noexcept {
            return this->_interval;
        }

        /// <summary>
        /// Invoke the callback for a <see cref="measurement" /> if it is set.
        /// </summary>
        /// <remarks>
        /// This method is not thread-safe. Callers must make sure that the
        /// instance is not changed while the callback is invoked from the
        /// sampler thread.
        /// </remarks>
        /// <param name="sample"></param>
        /// <returns><c>true</c> if the callback was invoked, <c>false</c> if it
        /// has not been set.</returns>
        bool invoke(_In_ const measurement& sample) const;

        /// <summary>
        /// Invoke the callback for <see cref="measurement_data" /> if it is
        /// set.
        /// </summary>
        /// <remarks>
        /// This method is not thread-safe. Callers must make sure that the
        /// instance is not changed while the callback is invoked from the
        /// sampler thread.
        /// </remarks>
        /// <param name="source"></param>
        /// <param name="sample"></param>
        /// <returns><c>true</c> if the callback was invoked, <c>false</c> if it
        /// has not been set.</returns>
        bool invoke(_In_ const sensor& source,
            _In_ const measurement_data& sample) const;

        /// <summary>
        /// Configures the asynchronous sampling such that it is disabled by
        /// removing all previously configured callbacks.
        /// </summary>
        /// <returns><c>*this</c>.</returns>
        async_sampling& is_disabled(void) noexcept;

        /// <summary>
        /// Configures the asynchronous sampler to pass the given context
        /// pointer around with every sample.
        /// </summary>
        /// <param name="context">A user-defined context pointer to be passed
        /// to the sampling callback. The caller is responsible for making sure
        /// that this pointer remains valid as long as the sensor is producing
        /// samples.</param>
        /// <returns><c>*this</c>.</returns>
        async_sampling& passing_context(_In_opt_ void *context) noexcept;

        /// <summary>
        /// Answer whether the <see cref="sensor" /> should produce samples of
        /// type <see cref="measurement" />.
        /// </summary>
        /// <returns></returns>
        inline bool produces_measurement(void) const noexcept {
            return (this->_on_measurement != nullptr);
        }

        /// <summary>
        /// Configures the <see cref="sensor" /> such that it produces samples
        /// of type <see cref="measurement" />.
        /// </summary>
        /// <param name="callback"></param>
        /// <returns><c>*this</c>.</returns>
        async_sampling& produces_measurement(
            _In_ const on_measurement_callback callback) noexcept;

        /// <summary>
        /// Answer whether the <see cref="sensor" /> should produce samples of
        /// type <see cref="measurement_data" />.
        /// </summary>
        /// <returns></returns>
        inline bool produces_measurement_data(void) const noexcept {
            return (this->_on_measurement_data != nullptr);
        }

        /// <summary>
        /// Configures the <see cref="sensor" /> such that it produces samples
        /// of type <see cref="measurement_data" />.
        /// </summary>
        /// <param name="callback"></param>
        /// <returns><c>*this</c>.</returns>
        async_sampling& produces_measurement_data(
            _In_ const on_measurement_data_callback callback) noexcept;

        /// <summary>
        /// Answer the resolution of the teimstamps to be produced.
        /// </summary>
        /// <returns>The resolution of the timestamps to be produced.</returns>
        inline timestamp_resolution resolution(void) const noexcept {
            return this->_timestamp_resolution;
        }

        /// <summary>
        /// Sets the desired sampling interval.
        /// </summary>
        /// <param name="interval">The desired sampling interval in
        /// microseconds.</param>
        /// <returns><c>*this</c>.</returns>
        async_sampling& sample_every(
            _In_ const microseconds_type interval) noexcept;

        /// <summary>
        /// Answer the Tinkerforge sensor data to obtain in case the sensor
        /// is a Tinkerforge sensor.
        /// </summary>
        /// <returns>A bitmask holding the sensors to retrieve.</returns>
        inline power_overwhelming::tinkerforge_sensor_source
        tinkerforge_sensor_source(void) const noexcept {
            return this->_tinkerforge_sensor_source;
        }

        /// <summary>
        /// Configures the <see cref="sensor" /> to produce timestamps of the
        /// specified resolution.
        /// </summary>
        /// <param name="resolution"></param>
        /// <returns><c>*this</c>.</returns>
        async_sampling& using_resolution(
            _In_ const timestamp_resolution resolution) noexcept;

        /// <summary>
        /// Move <paramref name="rhs" /> invalidating it.
        /// </summary>
        /// <param name="rhs">The object to be moved.</param>
        /// <returns><c>*this</c>.</returns>
        async_sampling& operator =(_Inout_ async_sampling&& rhs) noexcept;

        /// <summary>
        /// Answer whether the configuration enables asynchronous sampling.
        /// </summary>
        /// <returns><c>true</c> if asynchronous sampling is enabled,
        /// <c>false</c> otherwise.</returns>
        inline operator bool(void) const noexcept {
            return (this->produces_measurement()
                || this->produces_measurement_data());
        }

    private:

        void *_context;
        microseconds_type _interval;
        on_measurement_callback _on_measurement;
        on_measurement_data_callback _on_measurement_data;
        timestamp_resolution _timestamp_resolution;
        power_overwhelming::tinkerforge_sensor_source
            _tinkerforge_sensor_source;
    };

} /* namespace power_overwhelming */
} /* namespace visus */
